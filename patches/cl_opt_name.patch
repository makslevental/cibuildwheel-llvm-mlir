diff --git a/llvm/include/llvm/Support/CommandLine.h b/llvm/include/llvm/Support/CommandLine.h
index 49f4a668ae41..11bdb1e833d7 100644
--- a/llvm/include/llvm/Support/CommandLine.h
+++ b/llvm/include/llvm/Support/CommandLine.h
@@ -185,8 +185,7 @@ private:
   void registerCategory();
 
 public:
-  OptionCategory(StringRef const Name,
-                 StringRef const Description = "")
+  OptionCategory(StringRef const Name, StringRef const Description = "")
       : Name(Name), Description(Description) {
     registerCategory();
   }
@@ -212,7 +211,7 @@ protected:
 public:
   SubCommand(StringRef Name, StringRef Description = "")
       : Name(Name), Description(Description) {
-        registerSubCommand();
+    registerSubCommand();
   }
   SubCommand() = default;
 
@@ -393,7 +392,8 @@ public:
                              bool MultiArg = false);
 
   // Prints option name followed by message.  Always returns true.
-  bool error(const Twine &Message, StringRef ArgName = StringRef(), raw_ostream &Errs = llvm::errs());
+  bool error(const Twine &Message, StringRef ArgName = StringRef(),
+             raw_ostream &Errs = llvm::errs());
   bool error(const Twine &Message, raw_ostream &Errs) {
     return error(Message, StringRef(), Errs);
   }
@@ -446,8 +446,7 @@ template <class Ty> initializer<Ty> init(const Ty &Val) {
   return initializer<Ty>(Val);
 }
 
-template <class Ty>
-list_initializer<Ty> list_init(ArrayRef<Ty> Vals) {
+template <class Ty> list_initializer<Ty> list_init(ArrayRef<Ty> Vals) {
   return list_initializer<Ty>(Vals);
 }
 
@@ -502,7 +501,8 @@ template <typename R, typename C, typename... Args>
 struct callback_traits<R (C::*)(Args...) const> {
   using result_type = R;
   using arg_type = std::tuple_element_t<0, std::tuple<Args...>>;
-  static_assert(sizeof...(Args) == 1, "callback function must have one and only one parameter");
+  static_assert(sizeof...(Args) == 1,
+                "callback function must have one and only one parameter");
   static_assert(std::is_same_v<result_type, void>,
                 "callback return type must be void");
   static_assert(std::is_lvalue_reference_v<arg_type> &&
@@ -528,7 +528,7 @@ struct GenericOptionValue {
 
 protected:
   GenericOptionValue() = default;
-  GenericOptionValue(const GenericOptionValue&) = default;
+  GenericOptionValue(const GenericOptionValue &) = default;
   GenericOptionValue &operator=(const GenericOptionValue &) = default;
   ~GenericOptionValue() = default;
 
@@ -569,7 +569,7 @@ template <class DataType> class OptionValueCopy : public GenericOptionValue {
   bool Valid = false;
 
 protected:
-  OptionValueCopy(const OptionValueCopy&) = default;
+  OptionValueCopy(const OptionValueCopy &) = default;
   OptionValueCopy &operator=(const OptionValueCopy &) = default;
   ~OptionValueCopy() = default;
 
@@ -607,7 +607,7 @@ struct OptionValueBase<DataType, false> : OptionValueCopy<DataType> {
 
 protected:
   OptionValueBase() = default;
-  OptionValueBase(const OptionValueBase&) = default;
+  OptionValueBase(const OptionValueBase &) = default;
   OptionValueBase &operator=(const OptionValueBase &) = default;
   ~OptionValueBase() = default;
 };
@@ -863,7 +863,8 @@ public:
   ///
   template <class DT>
   void addLiteralOption(StringRef Name, const DT &V, StringRef HelpStr) {
-    assert(findOption(Name) == Values.size() && "Option already exists!");
+    assert(findOption(Name) == Values.size() &&
+           Twine("Option " + Name + " already exists!"));
     OptionInfo X(Name, static_cast<DataType>(V), HelpStr);
     Values.push_back(X);
     AddLiteralOption(Owner, Name);
@@ -1263,7 +1264,7 @@ template <unsigned n> struct applicator<const char[n]> {
     O.setArgStr(Str);
   }
 };
-template <> struct applicator<StringRef > {
+template <> struct applicator<StringRef> {
   template <class Opt> static void opt(StringRef Str, Opt &O) {
     O.setArgStr(Str);
   }
@@ -1297,7 +1298,7 @@ template <> struct applicator<MiscFlags> {
 
 // Apply modifiers to an option in a type safe way.
 template <class Opt, class Mod, class... Mods>
-void apply(Opt *O, const Mod &M, const Mods &... Ms) {
+void apply(Opt *O, const Mod &M, const Mods &...Ms) {
   applicator<Mod>::opt(M, *O);
   apply(O, Ms...);
 }
@@ -1486,7 +1487,7 @@ public:
   }
 
   template <class... Mods>
-  explicit opt(const Mods &... Ms)
+  explicit opt(const Mods &...Ms)
       : Option(llvm::cl::Optional, NotHidden), Parser(*this) {
     apply(this, Ms...);
     done();
@@ -1587,9 +1588,7 @@ public:
   reference operator[](size_type pos) { return Storage[pos]; }
   const_reference operator[](size_type pos) const { return Storage[pos]; }
 
-  void clear() {
-    Storage.clear();
-  }
+  void clear() { Storage.clear(); }
 
   iterator erase(const_iterator pos) { return Storage.erase(pos); }
   iterator erase(const_iterator first, const_iterator last) {
@@ -1726,7 +1725,7 @@ public:
   void setNumAdditionalVals(unsigned n) { Option::setNumAdditionalVals(n); }
 
   template <class... Mods>
-  explicit list(const Mods &... Ms)
+  explicit list(const Mods &...Ms)
       : Option(ZeroOrMore, NotHidden), Parser(*this) {
     apply(this, Ms...);
     done();
@@ -1882,7 +1881,7 @@ public:
   }
 
   template <class... Mods>
-  explicit bits(const Mods &... Ms)
+  explicit bits(const Mods &...Ms)
       : Option(ZeroOrMore, NotHidden), Parser(*this) {
     apply(this, Ms...);
     done();
@@ -1934,7 +1933,8 @@ class alias : public Option {
     if (!AliasFor)
       error("cl::alias must have an cl::aliasopt(option) specified!");
     if (!Subs.empty())
-      error("cl::alias must not have cl::sub(), aliased option's cl::sub() will be used!");
+      error("cl::alias must not have cl::sub(), aliased option's cl::sub() "
+            "will be used!");
     Subs = AliasFor->Subs;
     Categories = AliasFor->Categories;
     addArgument();
@@ -1952,7 +1952,7 @@ public:
   }
 
   template <class... Mods>
-  explicit alias(const Mods &... Ms)
+  explicit alias(const Mods &...Ms)
       : Option(Optional, Hidden), AliasFor(nullptr) {
     apply(this, Ms...);
     done();
